<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>JPAllen.net</title>
 <link href="http://jpallen.net/atom.xml" rel="self"/>
 <link href="http://jpallen.net"/>
 <updated>2013-07-25T17:37:35+01:00</updated>
 <id>http://jpallen.net</id>
 <author>
   <name>James Allen</name>
   <email>me@jpallen.net</email>
 </author>

 
 <entry>
   <title>Lifecycle Emails</title>
   <link href="http://jpallen.net/2013/07/25/lifecycle-emails"/>
   <updated>2013-07-25T00:00:00+01:00</updated>
   <id>http://jpallen.net/2013/07/25/lifecycle-emails</id>
   <content type="html">&lt;p&gt;&lt;em&gt;This post is based on a ten minute talk that I gave at &lt;a href=&#39;http://www.exeter-web.org/&#39;&gt;Exeter Web&lt;/a&gt; in July. The slides are available &lt;a href=&#39;/exeter-web-slides.pdf&#39;&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Lifecycle emails are about sending your customers relevant emails depending on where they are in their relationship with your product or service. When someone first signs up they&amp;#8217;re going to need help and advice with different things than someone who has been happily using your service for a few months but has recently stopped for some reason. Both of these users can be chased up with an appropriate lifecycle email and you&amp;#8217;ll hopefully be able to improve their experience, and learn more about what your customers want and value.&lt;/p&gt;

&lt;p&gt;When done correctly lifecycle emails are not at all spamy. Doing them correctly doesn&amp;#8217;t mean following a certain process perfectly, or sticking to any &amp;#8220;dos and don&amp;#8217;ts&amp;#8221;. Instead it means that you need to actually care about your users and genuinely mean what you say in your emails to them. When you ask for feedback you have to be ready to listen to what they say and embrace consider their suggestions when deciding how to go forward with your product or service. And when you send an email that looks like a personal conversation starter, you&amp;#8217;d better be ready to actually have that conversation when the person on the other end replies.&lt;/p&gt;

&lt;p&gt;When a user first signs up to your site you could send them an email like this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hi Joe, thanks a lot for signing up for AcmeWidgets! If you get lost, you can login again here.&lt;/p&gt;

&lt;p&gt;If you ever have any problems or questions (or even just a simple suggestion about something we could improve) then please feel free to get in touch directly by replying to this email.&lt;/p&gt;

&lt;p&gt;Regards, &lt;br /&gt; Bob &lt;br /&gt; Founder of AcmeWidgets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Almost every company sends out a &amp;#8216;welcome to our service&amp;#8217; email, but you should use this email to give you customers a chance to engage you in a conversation immediately. Offer them your personal attention if they want it, and make it clear that a reply to even this basic email will get them talking to someone behind the scenes.&lt;/p&gt;

&lt;p&gt;We tend to use services by imagining that they somehow just spring up and work. It&amp;#8217;s easy to forget that there are people behind the products you use, and as the person behind a product you want to make sure that your customers are aware of you and understand that you care a lot about your users. After all, if your users aren&amp;#8217;t happy and enjoying their experience then you&amp;#8217;re failing in at least one way. If you can remind users that there are people just like them behind the product and give them an opportunity to vent their frustrations and share their ideas and wants with you then you&amp;#8217;re in a great position. The sort of feedback that comes from your customers feeling empowered like that is incredible because they start to talk about what they actually want out your service, not just the incidental bugs or hiccups they are coming across.&lt;/p&gt;

&lt;p&gt;Another email you might send is when it&amp;#8217;s clear that a user is interested in your product and is using it day to day. Starting a free trial might be a good indicator of this, but I&amp;#8217;ll leave it to you to decide what is appropriate for your business.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hi Joe, I just noticed that you started a free trial and I wanted to reach out and see how you were getting on with AcmeWidgets. Has it helped to improve your Widget processes? Have you had a chance to try our Widget factory?&lt;/p&gt;

&lt;p&gt;I head up the development of our Widget Platform, so if you have any suggestions for what we could improve then please let me know. We&amp;#8217;re always open to feedback about what we can be doing better.&lt;/p&gt;

&lt;p&gt;Regards, &lt;br /&gt; Lucy &lt;br /&gt; Chief Engineer of AcmeWidgets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The idea here is to find out what people like about your service, and what the people who are in the most likely position to start paying for it think. It&amp;#8217;s not always nice to hear, but if people keep telling you that a certain thing just doesn&amp;#8217;t work for them then it&amp;#8217;s time to do something about it. But you need to give people a chance to tell you that first!&lt;/p&gt;

&lt;p&gt;If things don&amp;#8217;t go so well and a user abandons your site then it&amp;#8217;s important to know why. Was it because something was missing, or was it because they stuck at a difficult or confusing part of using your product? Let&amp;#8217;s find out!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hi Joe, I noticed that you haven&amp;#8217;t used AcmeWidgets for a while and I just wanted to check if you&amp;#8217;d had any problems that had put you off? Is there anything we can do to make AcmeWidgets easier for you to use?&lt;/p&gt;

&lt;p&gt;Please let me know if there&amp;#8217;s anything I can do to help get you back on track, or why AcmeWidgets isn&amp;#8217;t suitable for you.&lt;/p&gt;

&lt;p&gt;Regards, &lt;br /&gt; Bob &lt;br /&gt; Founder of AcmeWidgets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is another great chance for feedback, but it&amp;#8217;s also proactive customer support. The bar is set so low by most companies when it comes to customer support that simply by showing up and caring about your users you&amp;#8217;re going to delight them. And delighted users just love to share their stories with friends! It&amp;#8217;s a very powerful thing to reach out and say &amp;#8216;Hey, it looks like you had trouble. Let me help you with it.&amp;#8217; Most people just want to be productive, and so it&amp;#8217;s impressive when you reach out and say you&amp;#8217;re willing to invest some time that they didn&amp;#8217;t even ask for into getting your them up and running. We&amp;#8217;ve had more than one evangelical convert from this. Abandoned user to evangelical convert in just a few email exchanges? Not bad.&lt;/p&gt;

&lt;p&gt;I&amp;#8217;ll end with a final suggestion for an email, and undoubtably one of the most important. If a user stops paying for your product then find out why, and do everything in your power to negate this reason for the rest of your customers.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hi Joe, I&amp;#8217;m sorry to see that you cancelled your paid account. If you could spare a few minutes, I&amp;#8217;d love to hear what we did wrong. Is AcmeWidgets missing something that you need? We&amp;#8217;re always trying to improve our service so your feedback would be really valuable to us.&lt;/p&gt;

&lt;p&gt;Regards, &lt;br /&gt; Bob &lt;br /&gt; Founder of AcmeWidgets&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>Tracking down a memory leak in Node.js and Socket.IO</title>
   <link href="http://jpallen.net/2013/03/08/tracking-down-a-memory-leak-in-node-js-and-socket-io"/>
   <updated>2013-03-08T00:00:00+00:00</updated>
   <id>http://jpallen.net/2013/03/08/tracking-down-a-memory-leak-in-node-js-and-socket-io</id>
   <content type="html">&lt;p&gt;&lt;em&gt;If you are running&lt;/em&gt; &lt;strong&gt;Node.js 0.8&lt;/strong&gt; &lt;em&gt;and&lt;/em&gt; &lt;strong&gt;Socket.IO&lt;/strong&gt; &lt;em&gt;over&lt;/em&gt; &lt;strong&gt;HTTPS&lt;/strong&gt; &lt;em&gt;then you will be affected by this memory leak. See the bottom of the post for details of a fix.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Node.js is a great bit of kit, but it&amp;#8217;s still a relatively young technology. I was bitten by this recently when I had to investigate a large memory leak in one of the Node.js apps I maintain. There are tools that can help to track down these sorts of problems, but it still took lots of trial and error to understand, and I thought it would be worthwhile to share my experience here.&lt;/p&gt;

&lt;p&gt;Let me start by showing just how extreme the memory leak was. The graph below shows two very normal things that can happen in a Node.js app: connections coming in via WebSockets using the &lt;a href=&#39;http://socket.io/&#39;&gt;Socket.IO&lt;/a&gt; library, and uploading files. If we do either of these individually then there is no problem and the memory flattens off nicely, but when we send uploads and WebSocket connections together, &lt;strong&gt;BOOM&lt;/strong&gt;, there is linear memory growth:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#39;Memory leaking Node.js process&#39; src=&#39;/assets/images/posts/memory-leak.png&#39; /&gt;&lt;/p&gt;

&lt;p&gt;The Node.js version is 0.8.21 and the Socket.IO version is 0.9.13 here.&lt;/p&gt;

&lt;h2 id=&#39;getting_a_heapdump&#39;&gt;Getting a heapdump&lt;/h2&gt;

&lt;p&gt;Before doing any sort of debugging, I needed a snapshot of the state of the memory of the Node.js app. Since the memory leak was so extreme, I only had to wait a few minutes to be confident that a large proportion of the Node.js process&amp;#8217;s memory was taken up by the leaking objects. To get a dump of the process&amp;#8217;s memory, I used the &lt;a href=&#39;https://github.com/bnoordhuis/node-heapdump&#39;&gt;heapdump&lt;/a&gt; module. To take a snapshot of the current state of the program&amp;#8217;s memory, it&amp;#8217;s as simple as:&lt;/p&gt;
&lt;pre class=&#39;prettyprint language-js&#39;&gt;
heapdump = require(&quot;heapdump&quot;)
heapdump.writeSnapshot()
&lt;/pre&gt;
&lt;p&gt;Of course, there&amp;#8217;s no point doing this immediately when the application starts. A clever trick that we use for things like this is to allow telnet access directly to a REPL running in the context of the Node.js process (example in coffeescript):&lt;/p&gt;
&lt;pre class=&#39;prettyprint language-js&#39;&gt;
require(&quot;net&quot;)
  .createServer (socket) -&gt;
    repl = require(&#39;repl&#39;)
    repl.start(&quot;my-node-process&gt;&quot;, socket)
  .listen 5000, &quot;localhost&quot;
&lt;/pre&gt;
&lt;p&gt;I can then telnet in and take a snapshot after the process has grown it&amp;#8217;s memory footprint large enough to be worth investigating:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ telnet localhost 5000
my-node-process&amp;gt;require(&amp;quot;heapdump&amp;quot;).writeSnapshot()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will write out a file called something like &lt;code&gt;heapdump.1234567890.heapsnapshot&lt;/code&gt; to the same directory as the application&amp;#8217;s code.&lt;/p&gt;

&lt;h2 id=&#39;inspecting_the_heap_snapshot&#39;&gt;Inspecting the heap snapshot&lt;/h2&gt;

&lt;p&gt;Node.js is based on the V8 javascript engine used by the Chrome browser. This is very handy, because Chrome has a great debugging tool built in for inspecting heap snapshots from V8, and it works well for inspecting the heap snapshot of a Node.js process.&lt;/p&gt;

&lt;p&gt;To load the heap snapshot, open up the Chrome developer tools, and go to the &amp;#8216;Profiles&amp;#8217; tab. Right click in the left hand side bar, select &amp;#8216;Load Heap Snapshot&amp;#8217;, and load the snapshot that was taken previously by &lt;code&gt;heapdump&lt;/code&gt;. The heap snapshot inspector lets one see all the objects in ones Node.js app&amp;#8217;s memory at the time of the snapshot and shows how many of each object there are and how much memory they are using. After sorting by size, it was immediately clear that around 200Mb of my app&amp;#8217;s memory was taken up by buffers. Expanding the Buffer list, I saw that there were many 10Mb Buffers hanging around. Whatever is creating and holding onto those is undoubtably the cause of the leak.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#39;Chrome Heap Snapshot Inspected&#39; src=&#39;/assets/images/posts/chrome-heap-inspector.png&#39; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on an object in the heap inspector shows one the object&amp;#8217;s retaining tree. That is, the parent objects that hold a reference to that object, and the objects that hold a reference to those, and so on right up to the top level of your application. The way that Node.js&amp;#8217;s garbage collecting works means that an object will not be removed from memory until there are no references to it from elsewhere in the app. By examining a few of these buffers, it was clear that they were being held onto by a &lt;code&gt;req.head&lt;/code&gt; object which was referenced by a WebSocket object. At this point, Socket.IO was starting to look suspicious.&lt;/p&gt;

&lt;h2 id=&#39;the_problem&#39;&gt;The problem&lt;/h2&gt;

&lt;p&gt;A quick grep through the source code of Socket.IO quickly turned up the following lines as the likely origin of the leaking &lt;code&gt;req.head&lt;/code&gt; object:&lt;/p&gt;
&lt;pre class=&#39;prettyprint language-js&#39;&gt;
Manager.prototype.handleUpgrade = function (req, socket, head) {
  ...
  req.head = head
  ...
}
&lt;/pre&gt;
&lt;p&gt;This is called when a regular HTTP connection requests to be upgraded to a WebSocket connection. From the Node.js docs for the &lt;code&gt;upgrade&lt;/code&gt; event:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;head is an instance of Buffer, the first packet of the upgraded stream, this may be empty.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So it&amp;#8217;s a Buffer as expected. However, it&amp;#8217;s only the first packet, so it certainly shouldn&amp;#8217;t be taking up 10Mb by itself, and from the heap snapshot it looked like there were multiple &lt;code&gt;req.head&lt;/code&gt; objects pointing to the same Buffer. At this point I must admit to being a bit stuck and flailing around on Google for a while. I did eventually find the answer though:&lt;/p&gt;

&lt;p&gt;In Node.js version 0.8, the &lt;code&gt;tls&lt;/code&gt; module, which is used by the &lt;code&gt;https&lt;/code&gt; server in Node.js, allocates 10Mb &lt;code&gt;SlabBuffer&lt;/code&gt; objects up front. It does this because allocating a buffer is relatively slow, and rather than allocating new buffers for each incoming request it can instead quickly allocate portions of this large buffer. The &lt;code&gt;head&lt;/code&gt; buffer, which is passed to Socket.IO, is allocated from this 10Mb &lt;code&gt;SlabBuffer&lt;/code&gt;. Crucially, the Node.js garbage collector will not remove the &lt;code&gt;SlabBuffer&lt;/code&gt; until all of its children buffers are removed, but the &lt;code&gt;head&lt;/code&gt; buffer is kept around for the whole time that the WebSocket connection is open. This means that every WebSocket connection can potentially be keeping 10Mb of space hanging around in memory.&lt;/p&gt;

&lt;p&gt;This explains why our production process was seeing ever increasing memory usage. We had lots of traffic over HTTPS so lots of these 10Mb &lt;code&gt;SlabBuffer&lt;/code&gt;s were being created, and we also had people constantly connecting via WebSockets and hanging around for a while preventing the &lt;code&gt;SlabBuffer&lt;/code&gt;s from ever being freed from memory.&lt;/p&gt;

&lt;h2 id=&#39;the_fix&#39;&gt;The fix&lt;/h2&gt;

&lt;p&gt;It&amp;#8217;s hard to fault the design of Socket.IO here. There is no indication that keeping this small &lt;code&gt;head&lt;/code&gt; buffer around should have such dire consequences. It&amp;#8217;s also hard to fault the design in Node.js since in isolation the &lt;code&gt;SlabBuffer&lt;/code&gt; implementation is great idea for improving the speed of Node.js. I think this is just one of those subtle bugs from an unexpected interaction between two systems which both seem to be acting sensibly on the surface.&lt;/p&gt;

&lt;p&gt;There are a few patches out there which address this issue for Socket.IO: &lt;a href=&#39;https://github.com/LearnBoost/Socket.IO/pull/1143&#39;&gt;one here by jmatthewsr-ms&lt;/a&gt; and &lt;a href=&#39;https://github.com/LearnBoost/Socket.IO/pull/1178&#39;&gt;one here by me&lt;/a&gt;. These haven&amp;#8217;t been merged yet since there is some ongoing discussion about whose fault this really is. There is &lt;a href=&#39;https://github.com/joyent/node/pull/4660&#39;&gt;some suggestion&lt;/a&gt; that this should actually be fixed in Node.js to avoid catching others out in the future. Either way, I think this is a crucial problem that the community at large should be more aware of.&lt;/p&gt;

&lt;p&gt;For an immediate fix, you can monkey patch Socket.IO to include an additional last line in the &lt;code&gt;handleUpgrade&lt;/code&gt; method in &lt;code&gt;lib/manager.js&lt;/code&gt; which frees the &lt;code&gt;req.head&lt;/code&gt; buffer:&lt;/p&gt;
&lt;pre class=&#39;prettyprint language-js&#39;&gt;
Manager.prototype.handleUpgrade = function (req, socket, head) {
  var data = this.checkRequest(req)
    , self = this;

  if (!data) {
    if (this.enabled(&#39;destroy upgrade&#39;)) {
      socket.end();
      this.log.debug(&#39;destroying non-Socket.IO upgrade&#39;);
    }

    return;
  }

  req.head = head;
  this.handleClient(data, req);

  // Insert this line:
  delete req.head;
};
&lt;/pre&gt;
&lt;p&gt;A fix which I haven&amp;#8217;t tested but may help without solving the underlying cause is to shrink the size of the SlabBuffers allocated by the &lt;code&gt;tls&lt;/code&gt; module:&lt;/p&gt;
&lt;pre class=&#39;prettyprint language-js&#39;&gt;
require(&#39;tls&#39;).SLAB_BUFFER_SIZE = 100 * 1024 # 100Kb
&lt;/pre&gt;
&lt;p&gt;You can only do this in Node 0.8.20 and above though. I haven&amp;#8217;t tested this to see if makes much difference, or what affect it has on speed. Use at your own risk.&lt;/p&gt;

&lt;h2 id=&#39;conclusion&#39;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a subtle bug, yet I suspect it is responsible for many of the complaints about Socket.IO being a memory hog. The mix of circumstances are almost certainly found in a large number of production services. WebSockets are a common use case for Node.js and everyone should be using HTTPS wherever possible.&lt;/p&gt;

&lt;p&gt;If this is something which has affected you and my post has helped out, please let me know. Contact details are in the side bar.&lt;/p&gt;</content>
 </entry>
 
 
</feed>