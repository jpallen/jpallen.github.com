<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>JPAllen.net</title>
 <link href="http://jpallen.net/atom.xml" rel="self"/>
 <link href="http://jpallen.net"/>
 <updated>2013-03-10T21:41:55+00:00</updated>
 <id>http://jpallen.net</id>
 <author>
   <name>James Allen</name>
   <email>me@jpallen.net</email>
 </author>

 
 <entry>
   <title>Tracking down a memory leak in Node.js and Socket.IO</title>
   <link href="http://jpallen.net/2013/03/08/tracking-down-a-memory-leak-in-node-js-and-socket-io"/>
   <updated>2013-03-08T00:00:00+00:00</updated>
   <id>http://jpallen.net/2013/03/08/tracking-down-a-memory-leak-in-node-js-and-socket-io</id>
   <content type="html">&lt;p&gt;&lt;em&gt;If you are running&lt;/em&gt; &lt;strong&gt;Node.js 0.8&lt;/strong&gt; &lt;em&gt;and&lt;/em&gt; &lt;strong&gt;Socket.IO&lt;/strong&gt; &lt;em&gt;over&lt;/em&gt; &lt;strong&gt;HTTPS&lt;/strong&gt; &lt;em&gt;then you will be affected by this memory leak. See the bottom of the post for details of a fix.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Node.js is a great bit of kit, but it&amp;#8217;s still a relatively young technology. I was bitten by this recently when I had to investigate a large memory leak in one of the Node.js apps I maintain. There are tools that can help to track down these sorts of problems, but it still took lots of trial and error to understand, and I thought it would be worthwhile to share my experience here.&lt;/p&gt;

&lt;p&gt;Let me start by showing just how extreme the memory leak was. The graph below shows two very normal things that can happen in a Node.js app: connections coming in via WebSockets using the &lt;a href='http://socket.io/'&gt;Socket.IO&lt;/a&gt; library, and uploading files. If we do either of these individually then there is no problem and the memory flattens off nicely, but when we send uploads and WebSocket connections together, &lt;strong&gt;BOOM&lt;/strong&gt;, there is linear memory growth:&lt;/p&gt;

&lt;p&gt;&lt;img src='/assets/images/posts/memory-leak.png' alt='Memory leaking Node.js process' /&gt;&lt;/p&gt;

&lt;p&gt;The Node.js version is 0.8.21 and the Socket.IO version is 0.9.13 here.&lt;/p&gt;

&lt;h2 id='getting_a_heapdump'&gt;Getting a heapdump&lt;/h2&gt;

&lt;p&gt;Before doing any sort of debugging, I needed a snapshot of the state of the memory of the Node.js app. Since the memory leak was so extreme, I only had to wait a few minutes to be confident that a large proportion of the Node.js process&amp;#8217;s memory was taken up by the leaking objects. To get a dump of the process&amp;#8217;s memory, I used the &lt;a href='https://github.com/bnoordhuis/node-heapdump'&gt;heapdump&lt;/a&gt; module. To take a snapshot of the current state of the program&amp;#8217;s memory, it&amp;#8217;s as simple as:&lt;/p&gt;
&lt;pre class='prettyprint language-js'&gt;
heapdump = require(&quot;heapdump&quot;)
heapdump.writeSnapshot()
&lt;/pre&gt;
&lt;p&gt;Of course, there&amp;#8217;s no point doing this immediately when the application starts. A clever trick that we use for things like this is to allow telnet access directly to a REPL running in the context of the Node.js process (example in coffeescript):&lt;/p&gt;
&lt;pre class='prettyprint language-js'&gt;
require(&quot;net&quot;)
  .createServer (socket) -&gt;
    repl = require('repl')
    repl.start(&quot;my-node-process&gt;&quot;, socket)
  .listen 5000, &quot;localhost&quot;
&lt;/pre&gt;
&lt;p&gt;I can then telnet in and take a snapshot after the process has grown it&amp;#8217;s memory footprint large enough to be worth investigating:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ telnet localhost 5000
my-node-process&amp;gt;require(&amp;quot;heapdump&amp;quot;).writeSnapshot()&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will write out a file called something like &lt;code&gt;heapdump.1234567890.heapsnapshot&lt;/code&gt; to the same directory as the application&amp;#8217;s code.&lt;/p&gt;

&lt;h2 id='inspecting_the_heap_snapshot'&gt;Inspecting the heap snapshot&lt;/h2&gt;

&lt;p&gt;Node.js is based on the V8 javascript engine used by the Chrome browser. This is very handy, because Chrome has a great debugging tool built in for inspecting heap snapshots from V8, and it works well for inspecting the heap snapshot of a Node.js process.&lt;/p&gt;

&lt;p&gt;To load the heap snapshot, open up the Chrome developer tools, and go to the &amp;#8216;Profiles&amp;#8217; tab. Right click in the left hand side bar, select &amp;#8216;Load Heap Snapshot&amp;#8217;, and load the snapshot that was taken previously by &lt;code&gt;heapdump&lt;/code&gt;. The heap snapshot inspector lets one see all the objects in ones Node.js app&amp;#8217;s memory at the time of the snapshot and shows how many of each object there are and how much memory they are using. After sorting by size, it was immediately clear that around 200Mb of my app&amp;#8217;s memory was taken up by buffers. Expanding the Buffer list, I saw that there were many 10Mb Buffers hanging around. Whatever is creating and holding onto those is undoubtably the cause of the leak.&lt;/p&gt;

&lt;p&gt;&lt;img src='/assets/images/posts/chrome-heap-inspector.png' alt='Chrome Heap Snapshot Inspected' /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on an object in the heap inspector shows one the object&amp;#8217;s retaining tree. That is, the parent objects that hold a reference to that object, and the objects that hold a reference to those, and so on right up to the top level of your application. The way that Node.js&amp;#8217;s garbage collecting works means that an object will not be removed from memory until there are no references to it from elsewhere in the app. By examining a few of these buffers, it was clear that they were being held onto by a &lt;code&gt;req.head&lt;/code&gt; object which was referenced by a WebSocket object. At this point, Socket.IO was starting to look suspicious.&lt;/p&gt;

&lt;h2 id='the_problem'&gt;The problem&lt;/h2&gt;

&lt;p&gt;A quick grep through the source code of Socket.IO quickly turned up the following lines as the likely origin of the leaking &lt;code&gt;req.head&lt;/code&gt; object:&lt;/p&gt;
&lt;pre class='prettyprint language-js'&gt;
Manager.prototype.handleUpgrade = function (req, socket, head) {
  ...
  req.head = head
  ...
}
&lt;/pre&gt;
&lt;p&gt;This is called when a regular HTTP connection requests to be upgraded to a WebSocket connection. From the Node.js docs for the &lt;code&gt;upgrade&lt;/code&gt; event:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;head is an instance of Buffer, the first packet of the upgraded stream, this may be empty.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So it&amp;#8217;s a Buffer as expected. However, it&amp;#8217;s only the first packet, so it certainly shouldn&amp;#8217;t be taking up 10Mb by itself, and from the heap snapshot it looked like there were multiple &lt;code&gt;req.head&lt;/code&gt; objects pointing to the same Buffer. At this point I must admit to being a bit stuck and flailing around on Google for a while. I did eventually find the answer though:&lt;/p&gt;

&lt;p&gt;In Node.js version 0.8, the &lt;code&gt;tls&lt;/code&gt; module, which is used by the &lt;code&gt;https&lt;/code&gt; server in Node.js, allocates 10Mb &lt;code&gt;SlabBuffer&lt;/code&gt; objects up front. It does this because allocating a buffer is relatively slow, and rather than allocating new buffers for each incoming request it can instead quickly allocate portions of this large buffer. The &lt;code&gt;head&lt;/code&gt; buffer, which is passed to Socket.IO, is allocated from this 10Mb &lt;code&gt;SlabBuffer&lt;/code&gt;. Crucially, the Node.js garbage collector will not remove the &lt;code&gt;SlabBuffer&lt;/code&gt; until all of its children buffers are removed, but the &lt;code&gt;head&lt;/code&gt; buffer is kept around for the whole time that the WebSocket connection is open. This means that every WebSocket connection can potentially be keeping 10Mb of space hanging around in memory.&lt;/p&gt;

&lt;p&gt;This explains why our production process was seeing ever increasing memory usage. We had lots of traffic over HTTPS so lots of these 10Mb &lt;code&gt;SlabBuffer&lt;/code&gt;s were being created, and we also had people constantly connecting via WebSockets and hanging around for a while preventing the &lt;code&gt;SlabBuffer&lt;/code&gt;s from ever being freed from memory.&lt;/p&gt;

&lt;h2 id='the_fix'&gt;The fix&lt;/h2&gt;

&lt;p&gt;It&amp;#8217;s hard to fault the design of Socket.IO here. There is no indication that keeping this small &lt;code&gt;head&lt;/code&gt; buffer around should have such dire consequences. It&amp;#8217;s also hard to fault the design in Node.js since in isolation the &lt;code&gt;SlabBuffer&lt;/code&gt; implementation is great idea for improving the speed of Node.js. I think this is just one of those subtle bugs from an unexpected interaction between two systems which both seem to be acting sensibly on the surface.&lt;/p&gt;

&lt;p&gt;There are a few patches out there which address this issue for Socket.IO: &lt;a href='https://github.com/LearnBoost/Socket.IO/pull/1143'&gt;one here by jmatthewsr-ms&lt;/a&gt; and &lt;a href='https://github.com/LearnBoost/Socket.IO/pull/1178'&gt;one here by me&lt;/a&gt;. These haven&amp;#8217;t been merged yet since there is some ongoing discussion about whose fault this really is. There is &lt;a href='https://github.com/joyent/node/pull/4660'&gt;some suggestion&lt;/a&gt; that this should actually be fixed in Node.js to avoid catching others out in the future. Either way, I think this is a crucial problem that the community at large should be more aware of.&lt;/p&gt;

&lt;p&gt;For an immediate fix, you can monkey patch Socket.IO to include an additional last line in the &lt;code&gt;handleUpgrade&lt;/code&gt; method in &lt;code&gt;lib/manager.js&lt;/code&gt; which frees the &lt;code&gt;req.head&lt;/code&gt; buffer:&lt;/p&gt;
&lt;pre class='prettyprint language-js'&gt;
Manager.prototype.handleUpgrade = function (req, socket, head) {
  var data = this.checkRequest(req)
    , self = this;

  if (!data) {
    if (this.enabled('destroy upgrade')) {
      socket.end();
      this.log.debug('destroying non-Socket.IO upgrade');
    }

    return;
  }

  req.head = head;
  this.handleClient(data, req);

  // Insert this line:
  delete req.head;
};
&lt;/pre&gt;
&lt;p&gt;A fix which I haven&amp;#8217;t tested but may help without solving the underlying cause is to shrink the size of the SlabBuffers allocated by the &lt;code&gt;tls&lt;/code&gt; module:&lt;/p&gt;
&lt;pre class='prettyprint language-js'&gt;
require('tls').SLAB_BUFFER_SIZE = 100 * 1024 # 100Kb
&lt;/pre&gt;
&lt;p&gt;You can only do this in Node 0.8.20 and above though. I haven&amp;#8217;t tested this to see if makes much difference, or what affect it has on speed. Use at your own risk.&lt;/p&gt;

&lt;h2 id='conclusion'&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is a subtle bug, yet I suspect it is responsible for many of the complaints about Socket.IO being a memory hog. The mix of circumstances are almost certainly found in a large number of production services. WebSockets are a common use case for Node.js and everyone should be using HTTPS wherever possible.&lt;/p&gt;

&lt;p&gt;If this is something which has affected you and my post has helped out, please let me know. Contact details are in the side bar.&lt;/p&gt;</content>
 </entry>
 
 
</feed>